// Пакеты по сути это папки, это структура каталогов вашей программы. Обычно принято создавать папки
// Ваше доменное имя наоборот, com.lisin.cars
// Если в Idea пакеты слипаются, то можно правой клавишей по пустой области (Рядом с Project)
// http://joxi.ru/ZrJzpbMC91daxr.jpg или https://pp.userapi.com/c846019/v846019096/6f14f/wavBB8Ao4Xc.jpg
package ru.foxit.grayfox;

/**
 * Author Car.java - GrayFox | Ilya Lisin
 * Contact: Skype: foxygameskype | Telegram: +7(925)316-65-82 | vk: https://vk.com/exsperto1
 * GitHub: https://github.com/FoxITeam and https://github.com/GrayFoxIT
 * encoding: UTF-8, Comments, remarks in Russian.
 */

import java.text.MessageFormat;

// Alt + Insert - Создать класс, пакеты, при фокусе на scr или на пакетах (выбрать пакет или папку и нажать комбинацию).
// Все классы в джаве принято именовать с большой буквы, это очень Важно!
// Переменные с маленькой буквы именуется, а второе слово в название переменной с большой (fillHandler)
public class Car {

    // Конструктор, это метод, который возвращает экземпляр класса, но как то настроенный.
     // То есть если todo | Экземпляр класса - это объект созданный по данному классу.
      // то Конструктор возвращает экземпляр класса.
     // По умолчанию у каждого класса есть конструктор по умолчанию и можно создать экземпляр класса из другого класса.
     // Конструктор по умолчанию не видно, но он есть под капотом джавы. Если нажать ALT+ INSERT, то IDEA нам предложит
     // какую то быструю вставку и первой же строкой будет конструктор

  private String model;
  private int year;
  private String color;

  // ALT + INSERT и мы выбрали конструктор.
        // По сути это метод, по имени этого класса "Car()", заметте - перегрузка методов тут позволена, так как она
     // заложена в самой джаве (эту инфу я взял с книги эккеля), без возвращаемых параметров(значения), ну то что в скобках бы передаем нужные параметры - их там нет,
     // но на самом деле оно есть, он возвращает метод возвращающий тип данного метода (класса). Но его так никто не записывает, так как он уже создан по умолчанию и от него смысла нет.
     // Но по умолчанию он будет до тех пор, пока вы не переопределите свой конструктор.
     // И так, для чего нужны конструкторы? Конструкторы это методы, которые нужны для инициализации (ну для создания объектов данного класса)
     // инициализированны уже какими либо значениями.
//     public Car() {
//     }

     // Конструктор нельзя сделать приватным, потому что он станет бесполезным тогда! Не, не то что нельзя!
     // Можно, почему, можно применять уровни доступа к конструктору, но приватным делать бессмысленно. Это как приватными делать геттеры и сеттеры, от которых толку потом не будет.
     // Еще раз повторю, если сделать private наш конструктор, его никто и никогда не вызовет.
     public Car(){
         model = "Lancer";
         year = 2010;
         color = "Orange";
     }
     // И теперь при вызове экземпляра класса, у нас конструктор будет выдавать стандартные значения из этого класса.
     // это очень удобно, когда мы просто хотим вызвать не вызывая конструктор.
     // Если пользователь хочет переназвать модель, указать свой год и перекрасить, пусть он это делает принудительно в своем коде.

     // Теперь мы можем переопределить конструктор и передать в него какие то параметры
     // Теперь можно вызвать конструктор, передав в него параметр модели принудительно.
     // и так, чтобы обратиться с такого конструктора с параметрами к модели, нужно написать перед model - this.
     // Еще раз, Видите что model серая? а почему, потому что мы обращаемся к параметру, а чтобы обратиться к
     // полю класса (а поле класса это todo | Каждый класс содержит набор полей (переменных) и методов (функции). Если переменная относиться ко всему классу, то она называется полем класса.)
     // чтобы обратиться к полю класса из метода, при вот таком вот перекрытии, а это нормальная практика при подобном перекрытии,
     // нужно использовать слово this. - то есть this.model
     // Ключевое слово this говорит нам о том, что мы обращаемся к данному классу, в котором находимся.
     // То есть this.moder это тоже самое, что Car.model, только в случае Car.model у нас не статический, по этому this.
     // То есть получить ссылку на самого себя. Но еще this нужно раскрурить, по этому мы можем назвать в параметрах конструктора
     // String carModel
//     public Car(String model){
//        model = "Vesta";
//     }
        //
     public Car(String carModel) {
         // и к модели мы присвоили carModel
         model = carModel;
     }

     // Создадим полностью параметризованный коструктор со всеми тремя переменными.

     public Car(String model, int year, String color) {
         this.model = model;
         this.year = year;
         this.color = color;
     }

    public String getModel() {
        return model;
    }

    public int getYear() {
        return year;
    }

    public String getColor() {
        return color;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public void setYear(int year) {
        this.year = year;
    }

    // Геттеры и сеттеры - это специальные методы, геттер - возвращает, сеттер - устанавливает. От англ туГет туСет.
    // Alt + Insert - создает их.
    // Геттеры и сеттеры ограничивают доступы к полу класса, через геттер можно обратиться, через сеттер установить.
    // Геттеры и сеттеры нужны для огранизации бизнес логики, допустим мы хотим перекрасить машину, но Вам нужно
    // узнать что цвет не прозрачный! И мы проверям тут, что if - если цвет прозрачный, устанавливать цвет не будем.
    public void setColor(String color) {
         if(color != null) {
             this.color = color;
         }else {
             System.out.println("Нельзя покрасить машину в прозрачный цвет.");
         }

    }

    // В данном случае (возвращаемся из класса инкапсуляция), только printInfo имеет открытый тип.
    // То есть пользователь(другой кодер) не должен иметь возможности
    // Ключевое слово new вызывает конструктор (конструктор класса)
     public void printInfo(){
         String pattern = "Наша марка машины {0}, год выпуска {1}, цвет машины {2}";
         System.out.println(MessageFormat.format(pattern, model, year, color));
     }
 }
